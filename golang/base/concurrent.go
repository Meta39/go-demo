package main

import (
	"fmt"
	"golang/base/concurrent"
)

/*
Concurrent 并发
并发编程在当前软件领域是一个非常重要的概念，随着CPU等硬件的发展，我们无一例外的想让我们的程序运行的快一点、再快一点。
Go语言在语言层面天生支持并发，充分利用现代CPU的多核优势，这也是Go语言能够大范围流行的一个很重要的原因。

基本概念
串行、并发与并行
串行：任务按严格顺序依次执行，前一个任务完成后，后一个任务才能开始。如：先洗菜，再切菜，再炒菜。
并发：任务交替执行，通过快速切换（时间片轮转）模拟“同时”运行，实际可能共享资源。如：一个人边煮汤、边切菜，交替进行两件或多件事。
并行：任务真正同时执行，需多核/多CPU/分布式系统支持。如：多人在起跑线听枪声同时起跑

串行、并发与并行关键对比：
维度		串行			并发						并行
执行方式	严格顺序		交替执行（逻辑同时）		真正同时执行
资源需求	单线程/单核	可单核（如多线程）			必须多核/多机
适用场景	简单流程		I/O密集型（如Web服务器）	计算密集型（如科学计算）
复杂度	低			中（需同步机制）			高（需任务分解）
示例技术	单线程程序	多线程、协程（Go/Async）	MPI、CUDA、Spark

并发、并行常见误区澄清（并发 ≠ 并行）
一、并发是任务调度的抽象（如单核多线程），并行是硬件执行的体现（如多核）。
二、并行是并发的子集：所有并行都是并发，但并发不一定是并行。

串行、并发与并行总结
串行：简单但低效，适合线性任务。
并发：通过任务切换提高资源利用率，解决阻塞问题。
并行：通过硬件加速，最大化计算能力。

进程、线程和协程
进程：操作系统资源分配的基本单位，拥有独立的地址空间、文件描述符、内存等。如：打开Chrome浏览器，那么就会有一个进程，可能会有多个线程。
线程：CPU调度的基本单位，属于同一进程的线程共享内存和文件资源，但拥有独立的栈和寄存器。如：Chrome浏览器有一个进程下面有多个线程。
协程：用户态轻量级线程，由程序员控制调度（非抢占式），在单线程内实现并发。如：一个线程下面有多个协程。Java的虚拟线程、go的协程等。

进程、线程和协程关联关系：进程里面有线程，线程里面有协程。

进程、线程和协程三者的核心对比
维度			进程					线程				协程
资源占用		高（独立内存）			中（共享内存）		极低（用户态栈）
切换开销		高（内核介入）			中（内核调度）		极低（用户自主控制）
并发能力		低（数百个）			中（数千个）		高（百万级）
数据共享		IPC（进程间通信）		直接共享（需同步）	共享变量（无需锁）
调度方式		操作系统抢占式			操作系统抢占式		用户协作式
典型应用		隔离性任务（如容器）	多核并行计算		高并发I/O（如Web服务器）

并发模型
一、线程&锁模型
二、Actor模型
三、CSP模型
四、Fork&Join模型

Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。
*/
func Concurrent() {
	fmt.Println("============ 并发 ============")
	//goroutine协程
	concurrent.Goroutine()
	//channel通道
	concurrent.Channel()
	//lock锁
	concurrent.Lock()
	//sync
	concurrent.Sync()
	//atomic原子操作
	concurrent.Atomic()
	fmt.Println("============ 并发 ============")
}
