package main

import "fmt"

/*
Pointer 指针
1、区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。
2、要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。
Go语言中的指针介绍：
任何程序数据载入内存后，在内存都有他们的地址，这就是指针。
而为了保存一个数据在内存中的地址，我们就需要指针变量。
比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。
这时候变量B就是一个指针变量。通过变量A和变量B都能找到我的座右铭。
Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：&（取地址）和*（根据地址取值）。

总结： 取地址操作符&和取值操作符*是一对互补操作符，&取出地址，*根据地址取出地址指向的值。
变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：
一、对变量进行取地址（&）操作，可以获得这个变量的指针变量。
二、指针变量的值是指针地址。
三、对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。
*/
func Pointer() {
	fmt.Println("============ 指针 ============")
	/*
		指针地址和指针类型
		每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。
		Go语言中使用&字符放在变量前面对变量进行“取地址”操作。
		Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等。
		取变量指针的语法如下：
		ptr := &v    // v的类型为T
		其中：
		v:代表被取地址的变量，类型为T
		ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。
	*/
	fmt.Println("指针地址和指针类型")
	a := 10 //定义一个变量a
	// 取变量a的地址，将指针保存到b中
	b := &a                                         //把变量a的内存地址赋值给b，因此b的值就算a的内存地址，但是b本身也有自己的内存地址。
	fmt.Printf("获取a的值和a的内存地址 a:%d ptr:%p\n", a, &a) //获取a的值和a的内存地址 a:10 ptr:0xc00001a078
	fmt.Printf("获取b的值和b的类型 b:%p type:%T\n", b, b)   //获取b的值和b的类型 b:0xc00001a078 type:*int
	fmt.Println("获取b的内存地址", &b)                     //获取b的内存地址 0xc00000e018

	//指针取值。在对普通变量使用&操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。
	fmt.Println("指针取值")
	fmt.Printf("type of b:%T\n", b) //*int
	c := *b                         // 指针取值（根据指针去内存取值）
	fmt.Printf("type of c:%T\n", c) //int
	//为什么c输出的值是10？而不是b保存的a的内存地址？就算因为 * 这个符号，就是根据内存地址取值。如果内存地址里面存的是另外一个变量的内存地址，则再根据这个内存地址取值。
	fmt.Printf("value of c:%v\n", c) //10

	//指针传值
	fmt.Println("指针传值")
	x := 10
	fmt.Printf("外部x =%v,指针地址 = %v\n\n", x, &x)
	modify1(x)     //传值
	fmt.Println(x) // 10
	modify2(&x)    //传指针地址
	fmt.Println(x) // 100

	/*
		new和make
		在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。
		而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。
		要分配内存，就引出来今天的new和make。
		Go语言中new和make是内建的两个函数，主要用来分配内存。

		new是一个内置的函数，它的函数签名如下：
		func new(Type) *Type
		其中，
		Type表示类型，new函数只接受一个参数，这个参数是一个类型
		*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。

		new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。

		new与make的区别
		1、二者都是用来做内存分配的。
		2、make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；
		3、而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。
	*/
	fmt.Println("new和make")
	d := new(int)                                                         //new关键字创建的变量是指针变量，因此得到的值是指针地址
	e := new(bool)                                                        //new关键字创建的变量是指针变量，因此得到的值是指针地址
	fmt.Printf("指针d的类型 = %T,指针d的值 =%v,指针d的指针%v,,指针d的值%v\n", d, d, &d, *d) // *int
	fmt.Printf("指针e的类型 = %T,指针e的值 =%v,指针e的指针%v,,指针e的值%v\n", e, e, &e, *e) // *bool
	fmt.Println("指针d的值", *d)                                              // 根据内存的指针地址取值 0
	fmt.Println("指针e的值", *e)                                              // 根据内存的指针地址取值 false
	fmt.Printf("d的类型为%T,&d的类型为%T\n", d, &d)
	//fmt.Println(d == &d)//因为d本身就是指针，存到内存里的值也是指针。&d获取的是指针d的指针，所以不能直接直接比较。
	//对指针d进行赋值，因此就需要根据指针地址取值进行赋值。而不能直接 d = 10。因为d存的是int类型的指针
	*d = 10
	fmt.Println("d的值为", *d)

	/*
		make也是用于内存分配的，区别于new，make只用于slice、map以及channel的内存创建，而且make返回的类型就是这三个类型本身，而不是他们的指针类型。
		因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。
		make函数的函数签名如下：
		func make(t Type, size ...IntegerType) Type
		make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。
	*/
	var f map[string]int         //定义f变量和f变量的类型
	f = make(map[string]int, 10) //初始化变量f，相当于java里的new 实例化。也只有实例化以后才能对f变量进行赋值。
	f["k"] = 100                 //对f变量map进行赋值 key = k，value = 100
	fmt.Println("定义一个map，然后初始化map，再进行赋值", f)

	fmt.Println("============ 指针 ============")
}

/*
传参是传的值，因此入参会在内存创建一个新的x变量赋值10和新的指针地址，所以修改只会修改当前函数内部的x值，不会修改外部x的值，因为二者内存的指针地址不是同一个。
如果把x放到全局变量，这样看会更明显
*/
func modify1(x int) {
	fmt.Printf("modify1修改前的x = %v,指针地址 = %v\n", x, &x)
	x = 100
}

// 传参传的是外部x的指针地址，因此函数内部修改的是x的指针的值，外部的x也会发生改变。
func modify2(x *int) {
	fmt.Printf("modify2修改前的x = %v,指针地址 = %v\n", *x, x)
	*x = 100
	fmt.Printf("modify2修改后的x = %v,指针地址 = %v\n", *x, x)
}
